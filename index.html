<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/07/hello-test/" class="article-date">
  <time class="dt-published" datetime="2022-10-07T14:00:00.000Z" itemprop="datePublished">2022-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%80%E5%91%A8linux%E8%B5%84%E8%AE%AF/">一周linux资讯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/07/hello-test/">一周Linux资讯 Vol. 3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>hello, World!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/07/hello-test/" data-id="cl8qsukv30000fbi584if5fix" data-title="一周Linux资讯 Vol. 3" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux_news_vol_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/29/linux_news_vol_2/" class="article-date">
  <time class="dt-published" datetime="2022-09-29T14:00:00.000Z" itemprop="datePublished">2022-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%80%E5%91%A8linux%E8%B5%84%E8%AE%AF/">一周linux资讯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/29/linux_news_vol_2/">一周Linux资讯 Vol. 2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一周Linux资讯-Vol-2"><a href="#一周Linux资讯-Vol-2" class="headerlink" title="一周Linux资讯 Vol. 2"></a>一周Linux资讯 Vol. 2</h3><p>文韬<br>2022.9.29</p>
<h4 id="linux动向"><a href="#linux动向" class="headerlink" title="linux动向"></a>linux动向</h4><ol>
<li>debian12发布了测试版本，命名为bookworm，当前内核版本为5.19。</li>
<li>linux v6.0已经到了rc7，预计很快就会正式发布，然后v6.1的merge-window就会开放。</li>
<li>MGLRU已经进入mm-stable了，预计会在v6.1合入。</li>
<li>rust很有可能也会在v6.1进入内核，现在已经有很多人在做前置的驱动开发，比如最近有人用rust写了一个mac显示驱动，并完成了最基础的渲染……</li>
</ol>
<hr>
<h4 id="CHERI"><a href="#CHERI" class="headerlink" title="CHERI"></a>CHERI</h4><p>CHERI： capability hardware enhanced RISC instructions</p>
<p>剑桥和arm等一起搞的一种技术，目的是解决内存安全问题：给内存访问&#x2F;指针加上“capability”，而不仅仅是一个地址。——类似于原来的addr是data，另外加上了metadata，描述其capability。（具体原理我没细看，感兴趣的朋友可以仔细研究研究）</p>
<p>基于这种技术，就可以搞出一个层次关系： 系统刚启动时是root，拥有所有内存的访问权；在其之下可以进行capability的分配，一层一层嵌套，最终实现内存的隔离与保护。——最终这种保护是落到cpu硬件支持的，所以更可靠。</p>
<p>最终就是形成了一个树：子节点不能突破父节点的域的限制，但是可以自我限制。</p>
<p>目前有一个实验性的架构，arm的Morello。</p>
<p>（毫无疑问，这种探索还是为了解决C&#x2F;C++的指针问题……）</p>
<p>LWN的介绍：<br><a target="_blank" rel="noopener" href="https://lwn.net/Articles/909265/">Supporting CHERI capabilities in GCC and glibc - lwn</a></p>
<p>官方PAPER（TL;DR）：<br><a target="_blank" rel="noopener" href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-941.pdf">An Introduction to CHERI</a></p>
<hr>
<h4 id="KASAN-x2F-fuzzing"><a href="#KASAN-x2F-fuzzing" class="headerlink" title="KASAN&#x2F;fuzzing"></a>KASAN&#x2F;fuzzing</h4><p>首先，最近有LSS（Linux Security Summit） 2022： <a target="_blank" rel="noopener" href="https://events.linuxfoundation.org/linux-security-summit-europe/">LSS 2022</a>，这是Andrey Konovalov(内核KASAN的核心开发者，reviewer)连续第三年在LSS上讨论KASAN了……（可以组成一个完整的系列哈哈哈）</p>
<p>KASAN，最初是用户空间的Address Sanitizer，Kernel版本就是KASAN，是内核dynamic bug detectors的其中一个，主要是检测内存越界访问，use-after-free，double-free等问题。</p>
<p>KASAN的基本原来不展开讨论了，可以参考内核文档。从基本机制而言，可以有几个部分：</p>
<ol>
<li>通过config开启</li>
<li>需要编译器支持（涉及到堆栈操作时的red-zone setup）</li>
<li>shadow memory（1&#x2F;8的内存用来存放trace数据，所以不适合布置在生产环境）</li>
<li>hook（比如alloc&#x2F;free路径之类的）</li>
<li>支持部分allocator（比如slab之类的，暂时不支持per-cpu）</li>
</ol>
<p>KASAN有两种常用场景：</p>
<ol>
<li>特定问题排查（比如已经发现了内存double-free问题，开启KASAN检测）</li>
<li>KASAN+fuzzing    ： 用fuzzing来发现潜藏的内存使用问题（核心使用方式）</li>
</ol>
<p>tag-based：shadow-memory based方案要占用大量内存，现在有新的实现方式：tag-based，其中又能分为software-tag和hardware-tag。貌似需要硬件支持，目前好像只有arm支持（arm有个MTE，arm memory tagging extensions），目的可能是之后能直接应用在生产环境。（我没细看，感兴趣的朋友可以自行深入了解一下；同时安全&#x2F;虚拟化等都有这样的趋势：从软件实现到硬件实现，以提高性能&#x2F;特性）</p>
<p>一些其他的Kernel Dynamic Bug Detector介绍：</p>
<ol>
<li>KMSAN，Kernel Memory Sanitizer，核心是用来检测未初始化内存的使用（这会有数据泄露风险，和安全问题高度相关）</li>
<li>KCSAN，Kernel Concurrency Sanitizer，并发检测，也就是并发&#x2F;加锁的检测。</li>
<li>KFENCE，好像和KASAN的目的差不多，但目标是能布置在生产环境，其原理好像是概率&#x2F;采样……</li>
</ol>
<p>lwn介绍文章：<br><a target="_blank" rel="noopener" href="https://lwn.net/Articles/909245/">Finding bugs with sanitizers - lwn</a></p>
<p>LSS系列：<br><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/10V_msbtEap9dNerKvTrRAzvfzYdrQFC8e2NYHCZYJDE/edit#slide=id.g1925acbbf3_0_0">2020, Android Security Symposium: Memory Tagging for the Kernel: Tag-Based KASAN - Andrey Konovalov</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1IpICtHR1T3oHka858cx1dSNRu2XcT79-RCRPgzCuiRk/edit#slide=id.gee201659dd_0_97">2021, Linux Security Summit: Mitigating Linux kernel memory corruptions with Arm Memory Tagging - Andrey Konovalov</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1qA8fqRDHKX_WM_ZdDN37EQQZwSTNJ4FFws82tbUSKxY/edit#slide=id.g1523988ae10_0_16">2022, LSS Europe: Sanitizing the Linux kernel - Andrey Konovalov</a></p>
<p>内核文档：<br><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html#software-tag-based-kasan">KASAN - kernel doc</a></p>
<hr>
<h4 id="flexiable-arrays"><a href="#flexiable-arrays" class="headerlink" title="flexiable arrays"></a>flexiable arrays</h4><p>这是GNU Tools上的一个讨论，因为和gcc&#x2F;clang相关。作者是Gustavo A. R. Silva, Google工程师，KSPP项目（Kernel Self Protection Project）</p>
<p>（我不太了解编译器细节，所以瞎聊一下，大家凑合着看个大概）</p>
<p>flex-arrays，我们在内核代码中可能看到过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct blob_holder &#123;</span><br><span class="line">    ...</span><br><span class="line">    size_t count;</span><br><span class="line">    unsigned char block[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用上，有三种形式（历史包袱）：</p>
<ol>
<li>[1] : 单元素表示，典型的hack，计算外部struct的sizeof时会算一个元素进去</li>
<li>[0] : 0元素表示，GNU extension（非c语言标准）,必须放在尾部，但编译器不能检测其使用是否正确……</li>
<li>[]  : 以后的规范使用方式</li>
</ol>
<p>在0元素方式中，一种典型的容易出错的场景是，不小心将包含了trailing-array的struct，嵌套到另外一个结构体内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct blob_holder;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在编译器中添加真正的flex-arrays支持之前，这种错误编译器是无法检测的。（可以认为在0元素hack中，编译器直接忽略了flex-arrays，算sizeof、layout的时候都不考虑它。）</p>
<p>编译器选项：<br>gcc13&#x2F;clang16: -fstrict-flex-arrays[&#x3D;n] (-fsfa)<br>（clang社区暂时表示拒绝，因为这是非c语言标准……emmm）</p>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/908817/">Safer flexible arrays for the kernel - lwn</a></p>
<hr>
<h4 id="intel：-codeplay-amp-oneAPI"><a href="#intel：-codeplay-amp-oneAPI" class="headerlink" title="intel： codeplay &amp; oneAPI"></a>intel： codeplay &amp; oneAPI</h4><p>intel的oneAPI项目已经做了好几年了，2022年6月收购了CodePlay，助力这个项目。最近宣布由CodePlay监督（oversee）该项目。（oneAPI还挺有意思的，所以简单聊一聊）</p>
<p>oneAPI的目的是为了在各种硬件架构之上，提供统一的编程框架，最后的目标是：“No transistor left behind”……</p>
<p>比如Intel的硬件架构大概可以分为SVMS四大阵营：</p>
<ul>
<li>标量Scalar： CPU</li>
<li>矢量Vector： GPU</li>
<li>矩阵Matrix： AI</li>
<li>空间Special： FPGA</li>
</ul>
<p>从功能上，有点类似于HLS（High level Synthesis，高层综合），能将高层语言转换为硬件语言，比如从c++到FPGA能读懂的RTL级别的语言。但是HLS更多的是面向硬件工程师的，做纯软的人很难用，而oneAPI更多的是面向软件工程师&#x2F;算法工程师的，能更好地遮蔽硬件相关的细节。</p>
<p>（oneAPI应该是Intel花大力气的一个项目，如果能做出来，做起来生态，那还是很有想象空间的）</p>
<p><a target="_blank" rel="noopener" href="https://www.phoronix.com/news/Intel-oneAPI-Innovation-2022">https://www.phoronix.com/news/Intel-oneAPI-Innovation-2022</a></p>
<hr>
<h4 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h4><p><strong>acl</strong></p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/linux-fsdevel/20220928160843.382601-1-brauner@kernel.org/T/#t">https://lore.kernel.org/linux-fsdevel/20220928160843.382601-1-brauner@kernel.org/T/#t</a></p>
<p>acl上最近有一个大的改动：Christian Brauner（idmapped mounts等子系统的维护者）最近发布了一个很大的patchset，在vfs中增加了posix-acl相关的api。——之前的实现是基于xattr的hack，有很多问题，这次是打算完全重构了。</p>
<p>简单介绍一下acl（我也不太懂，没深入研究过）： access control list，就是在常规的自主访问控制之外，可以基于文件&#x2F;目录，手动构建一些访问控制属性。</p>
<p><strong>FUSE BPF</strong></p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/linux-fsdevel/YzQ+ke3JIx69Plld@bfoster/T/#t">https://lore.kernel.org/linux-fsdevel/YzQ+ke3JIx69Plld@bfoster/T/#t</a></p>
<p>上周曾提过的fuse-passthrough&#x2F;bpf的后续，在LPC讨论之后，google工程师这周将其patch推到了上游。——这是一个超大的patch，超过一万行，目的是将fuse扩展为支持“stacked filesystem”。</p>
<p>（我还没来得及看这个patchset，可能是我后面一段时间的重点工作……）</p>
<p><strong>io_uring&#x2F;async-buffered-write</strong></p>
<p>最近io_uring的团队（facebook）给xfs和btrfs都增加了async buffered-write：原来的buffered-write在io_uring中都是直接走slow-path，现在会先尝试fast-path（也就是NOWAIT模式下，可以成功写入page-cache）。</p>
<p>在某些workload下，能显著提高io_uring下buffered-write的效率。——slow-path下需要好几次的上下文切换（底层原理就是将其交给io-worker去submit），而fast-path没有任何的上下文切换。</p>
<p>xfs：<br><a target="_blank" rel="noopener" href="https://lore.kernel.org/io-uring/20220601210141.3773402-1-shr@fb.com/">https://lore.kernel.org/io-uring/20220601210141.3773402-1-shr@fb.com/</a></p>
<p>btrfs：<br><a target="_blank" rel="noopener" href="https://lore.kernel.org/io-uring/CAL3q7H6AH+1Uc08y3XtgwN5nngoQGyxHLq18jaa+y+QqpK=B5g@mail.gmail.com/T/#t">https://lore.kernel.org/io-uring/CAL3q7H6AH+1Uc08y3XtgwN5nngoQGyxHLq18jaa+y+QqpK=B5g@mail.gmail.com/T/#t</a></p>
<hr>
<h4 id="net"><a href="#net" class="headerlink" title="net"></a>net</h4><p>最近看了一个非常好的net系列博客文章，推荐给大家：（网络和存储在架构上非常相似……）</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008836467">Linux网络 - 数据包的接收过程 - public0821</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008926093">Linux网络 - 数据包的发送过程 - public0821</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009251098">Linux虚拟网络设备之veth - public0821</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009249039">Linux虚拟网络设备之tun&#x2F;tap - public0821</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009491002">Linux虚拟网络设备之bridge - public0821</a></p>
<hr>
<h4 id="libvirt"><a href="#libvirt" class="headerlink" title="libvirt"></a>libvirt</h4><p>我最近尝试了一下用libvirt（virt-manager &#x2F; virsh）管理虚拟机，挺好用的。（尤其是virsh的命令行交互非常舒适）</p>
<p>关于其fs直通和gdb调试可以参考单独的文档。</p>
<p>fs直通也可以用nfs： 用9p做直通时，因为write是passthrough，所以效率很低（在虚拟机里编译内核简直是一种折磨）；我换成nfs之后就快多了，搭配上ccache，再也不用在host里cross-compile了……</p>
<p>（如果有人感兴趣的话我可以在之后简单介绍一下我习惯的开发环境搭建……）</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/29/linux_news_vol_2/" data-id="cl8qsukva0004fbi59k0bd1iy" data-title="一周Linux资讯 Vol. 2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux_news_vol_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/23/linux_news_vol_1/" class="article-date">
  <time class="dt-published" datetime="2022-09-23T14:00:00.000Z" itemprop="datePublished">2022-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%80%E5%91%A8linux%E8%B5%84%E8%AE%AF/">一周linux资讯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/23/linux_news_vol_1/">一周Linux资讯 Vol. 1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一周Linux资讯-Vol-1"><a href="#一周Linux资讯-Vol-1" class="headerlink" title="一周Linux资讯 Vol. 1"></a>一周Linux资讯 Vol. 1</h3><p>文韬<br>2022.9.23</p>
<h4 id="brightness-x2F-backlight"><a href="#brightness-x2F-backlight" class="headerlink" title="brightness&#x2F;backlight"></a>brightness&#x2F;backlight</h4><p>屏幕亮度&#x2F;背光控制的用户态接口正在大改：</p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1390/attachments/990/1916/kernel-recipes-backlight-2022-16x9.pdf">https://lpc.events/event/16/contributions/1390/attachments/990/1916/kernel-recipes-backlight-2022-16x9.pdf</a></p>
<p>作者Hans de Goede是redhat&#x2F;fedora的开发者，内核大佬，很多acpi&#x2F;platform&#x2F;drm相关子系统的维护者，所以预计大概率会在以后被合入（现在的接口确实有点让人迷糊……）</p>
<hr>
<h4 id="MGLRU"><a href="#MGLRU" class="headerlink" title="MGLRU"></a>MGLRU</h4><p>MGLRU貌似在业界大受好评，各种benchmark都表现得很不错，甚至被认为可能是2022内核的最大创新。一些发行版已经提前合入了，比如openwrt，谷歌内部的一些os（MGLRU是chromeos团队开发的）等。尤其是对于低内存设备，用户体验效果大大提高了（所以openwrt这么积极……它是给嵌入式设备用的）</p>
<p>其它的一些：</p>
<ol>
<li>目前已经发布了v15，看起来有机会在6.1合入。</li>
<li>貌似有官方的backport版本？</li>
<li>MGLRU和eBPF有结合，开放了一些策略给用户空间，比如generation的赋值。（很有想象空间？）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.phoronix.com/news/MGLRU-LPC-2022">https://www.phoronix.com/news/MGLRU-LPC-2022</a><br><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1269/attachments/1024/1969/The%20Multi-gen%20LRU%20-%20LPC%202022.pdf">https://lpc.events/event/16/contributions/1269/attachments/1024/1969/The%20Multi-gen%20LRU%20-%20LPC%202022.pdf</a><br>（双语能力好的同学可以去看LPC的视频）</p>
<hr>
<h4 id="vDSO-getrandom"><a href="#vDSO-getrandom" class="headerlink" title="vDSO-getrandom()"></a>vDSO-getrandom()</h4><p>getrandom()接口大幅提速：（15x？）</p>
<p><a target="_blank" rel="noopener" href="https://www.zx2c4.com/projects/linux-rng-5.17-5.18/inside-linux-kernel-rng-presentation-sept-13-2022.pdf">https://www.zx2c4.com/projects/linux-rng-5.17-5.18/inside-linux-kernel-rng-presentation-sept-13-2022.pdf</a></p>
<ol>
<li><p>这是在vDSO接口里，这是syscall的一种优化路径，就是内核把一部分函数接口，作为虚拟动态共享库导出给用户空间直接使用，省去常规的上下文切换开销，常见的还有gettimeofday，一般是一些性能敏感、无安全风险的接口。</p>
</li>
<li><p>这个改动里面我没细看，大概也看不太懂</p>
</li>
<li><p>作者已经做了backport，4.19&#x2F;5.10都有，所以可以考虑关注一下。</p>
</li>
</ol>
<hr>
<h4 id="128-bit-zettalinux"><a href="#128-bit-zettalinux" class="headerlink" title="128-bit zettalinux"></a>128-bit zettalinux</h4><p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/908026/">https://lwn.net/Articles/908026/</a></p>
<ul>
<li>zettalinux：<ul>
<li>想得很远，128-bits（是否有必要？）</li>
<li>一个原因是，bits还可以给安全功能用……（比如现在的64bits，经常分为48+16，16用来打tag……）</li>
<li>HIGHMEM之类的可以永久退役……</li>
<li>如果真的要更改，如何更改？</li>
<li>cpu架构支持，128-bits寄存器……</li>
<li>类型定义，尤其是long和指针之间的关系</li>
<li>用户接口定义和兼容性问题：</li>
<li>如何在128-bits机器上跑32&#x2F;64bits kernel</li>
<li>如何在128-bits机器&#x2F;内核上 ，跑32&#x2F;64bits用户程序</li>
<li>如何推动这个问题？——现在还没有这种机器……</li>
<li>用qemu，模拟一个这种机器吧！</li>
<li>……</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Intel-DSA"><a href="#Intel-DSA" class="headerlink" title="Intel-DSA"></a>Intel-DSA</h4><p><a target="_blank" rel="noopener" href="https://www.phoronix.com/news/Intel-DSA-2.0-Linux-Start">https://www.phoronix.com/news/Intel-DSA-2.0-Linux-Start</a><br><a target="_blank" rel="noopener" href="https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator">https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator</a></p>
<p>dsa, data stream accelerator，数据流加速器，和之前的DMA功能类似，貌似是现在Intel高速数据io的方向，搞了好几年时间了，可能差不多上线了（大概率会先在服务器处理器上）。</p>
<p>我稍微瞄了一眼它的说明，大概是利用PCI-E的很多新特性，实现一个集成在处理器内部的data-move加速器，来高效处理各种数据访问&#x2F;搬运工作：存储、网络、持久性内存之类的。</p>
<p>在实现上，应该是依赖于PCI-E的很多高级特性，最后大概是一个SVM（shared-virtual-memory）的搞法，让设备可以直接访问到各个进程的地址空间，并且不用现在的各种pin（现在用DMA+IOMMU也可以实现一些类似的功能，但貌似比较麻烦？要很小心地处理缓存一致性问题？貌似和直接使用进程的地址空间还是有不小的差别）</p>
<p>如果有对PCI-E体系很感兴趣的同学，大概可以关注一下这个方向，如果能把DMA&#x2F;IOMMU&#x2F;PCI-E&#x2F;ACPI等硬件体系架构相关的内容搞搞懂，带带我们就更好了</p>
<hr>
<h4 id="loongarch：acpi-patch"><a href="#loongarch：acpi-patch" class="headerlink" title="loongarch：acpi patch"></a>loongarch：acpi patch</h4><p><a target="_blank" rel="noopener" href="https://lore.kernel.org/linux-acpi/20220919021540.2873061-1-chenhuacai@loongson.cn/t/#u">[PATCH V4] LoongArch: Add ACPI-based generic laptop driver @ 2022-09-19  2:15 Huacai Chen</a></p>
<ul>
<li>loongarch：<ul>
<li>（不太懂，转发）</li>
<li>drivers&#x2F;platform&#x2F;loongarh-laptop?</li>
</ul>
</li>
</ul>
<hr>
<h4 id="内存管理：Memory-Tiering"><a href="#内存管理：Memory-Tiering" class="headerlink" title="内存管理：Memory Tiering"></a>内存管理：Memory Tiering</h4><p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1266/attachments/1023/1968/LPC2022%20Memory%20Tiering.pdf">Memory Tiering - Jérôme Glisse &#x2F; Google</a></p>
<p>作者J. Glisse, 是heterogeneous memory manage的维护者（异构内存管理）。</p>
<p>文章里有一个内存的层级图很好，register&#x2F;cache&#x2F;HBM&#x2F;local-ddr&#x2F;remote-ddr&#x2F;CXL-ddr&#x2F;nvm&#x2F;over-network……（延迟、带宽、容量）</p>
<p>内存分层的核心是cold&#x2F;hot的判定策略，以及迁移算法之类的……（当然又会涉及到一些探讨：策略是全局统一的，还是分group的？或者启发式的？或者开放给用户空间，bpf定制？）</p>
<hr>
<h4 id="内存管理：maple-tree"><a href="#内存管理：maple-tree" class="headerlink" title="内存管理：maple-tree"></a>内存管理：maple-tree</h4><p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/845507/">Introducing maple trees - lwn</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1226/attachments/1116/2145/Maple_Tree.pdf">The Maple Tree - Liam R. Howlett (LPC 2022)</a></p>
<p><a target="_blank" rel="noopener" href="https://blogs.oracle.com/linux/post/the-maple-tree-a-modern-data-structure-for-a-complex-problem">The Maple Tree, A Modern Data Structure for a Complex Problem - Liam R. Howlett (blog)</a></p>
<p>maple-tree，试图解决vma的管理问题。——vma当前使用的是rbtree+list，存在一些问题，比如顺序遍历效率、rcu-safe、全局mmap_lock等问题。</p>
<p>maple-tree是一种变种的btree，可以认为是range&#x2F;gap btree。——vma经常要查找一段足够长的gap，如果有gap的记录，搜索起来会更高效。</p>
<p>maple-tree设计的核心要点是rcu-safe，这样才能尽量用rcu保护，而不是大锁。——rcu-safe我也没搞太懂，大意是rbtree旋转时会涉及多个node，而btree在调整时都是单node的。</p>
<p>maple-tree对cache更友好。——里面的细节比较多，可以直接看文章。（现在在内核设计个东西，不考虑cache都不能拿出手……）</p>
<p>maple-tree除了在vma之外，还有潜在的使用场景，比如pid管理，page-cache，extent管理……——目前内核的核心数据结构：list, hlist&#x2F;buckets, btree, rbtree, radix-tree&#x2F;xarray, …</p>
<p>一些补充材料：</p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20210514204440.ofwxmcdm6nrmur6m@revolver/">[PATCH 00&#x2F;94] Introducing the Maple Tree @ 2021-04-28 15:35 Liam Howlett</a></p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20211201142918.921493-16-Liam.Howlett@oracle.com/t/#u">[PATCH v4 00&#x2F;66] Introducing the Maple Tree @ 2021-12-01 14:29 Liam Howlett</a></p>
<hr>
<h4 id="调度：latency-hints-for-CFS-task"><a href="#调度：latency-hints-for-CFS-task" class="headerlink" title="调度：latency hints for CFS task"></a>调度：latency hints for CFS task</h4><p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1273/attachments/975/1898/latency_LPC_sched_MC_2022.pdf">Latency hints for CFS task - Vincent Guittot LPC’22</a></p>
<p>作者Vincent Guittot是scheduler的co-maintainer，所以将来合入的可能性很大。latentcy和桌面环境还是比较相关的。</p>
<p>cfs的核心思路是：大家的优先级（nice值）都只是影响vruntime的计算，而在调度决策时一视同仁，简单地根据vruntime比大小。——越小的就越应该优先得到执行机会。但这可能导致不合理的切换：比如进程A刚开始执行1us，就被切换走了；或者A和B，两个人的vruntime差不多，A执行一下就比B多，所以切换到B；B执行一下又超过了A，于是又切换到A，如此循环……</p>
<p>所以，引入了一些参数来进行抢占限制（可以通过sysctl调整）：</p>
<ul>
<li>kernel.sched_child_runs_first         ： 默认为1</li>
<li>kernel.sched_latency_ns               : “一轮”的时间（全部得到执行机会）</li>
<li>kernel.sched_min_granularity_ns       ： 抢占时应保证的最小执行时间</li>
<li>kernel.sched_wakeup_granularity_ns    ： wakup时的抢占限制</li>
<li>……</li>
</ul>
<p>现在引入一个新的参数kernel.sched_latency，在preempt中参与判定。比如对于latency敏感的task，可以提前抢占（抢占掉当前运行的lower vruntime进程）之类的。</p>
<p>（注意，latency仅仅影响抢占的优先级，但不影响vruntime的计算，也不影响全局的公平性……）</p>
<p>文中还提到一个测试工具软件包： rc-tests，其中有hackbench（进程负载模拟&#x2F;压力测试？），cyclictest（实时性测试？）之类的……</p>
<p>一些补充材料：</p>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/solutions/177953">About use of kernel parameter ‘sched’ - Red Hat</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/789487">Linux调度器何时需触发抢占？—— 从hackbench谈起 - aliyun</a></p>
<p><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/d4467cd50d884b438dc8c2993669bed0@AcuMS.aculab.com/t/#u">[PATCH v2 0&#x2F;7]  Add latency_nice priority @ 2022-05-12 16:35 Vincent Guittot</a></p>
<hr>
<h4 id="调度：Nest-Scheduling"><a href="#调度：Nest-Scheduling" class="headerlink" title="调度：Nest Scheduling"></a>调度：Nest Scheduling</h4><p><a target="_blank" rel="noopener" href="https://www.phoronix.com/news/Nest-Linux-Scheduling-Warm-Core">“Nest” Is An Interesting New Take On Linux Kernel Scheduling For Better CPU Performance - phoronix</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1198/attachments/983/1909/plumbers.pdf">OS Scheduling with Nest: Keeping Tasks Close Together on Warm Cores - Julia Lawall LPC’22</a></p>
<p>尝试解决的核心问题是： task被调度到一个idle-core时，其电压频率太低，运算速度太慢。如何解决？让刚刚进入idle的core保持“warm”，同时尽可能将task调度到warm-idle-core上去。</p>
<p>如何实现？给core分层（nest）：primary-set&#x2F;preserve-set&#x2F;normal-set，根据执行情况，core的位置会动态调整。比如primary-set里有很多core，其中可能有task已经退出的，已经进入idle的，也就是“空穴”。为了保持它的warm，可以将它的idle策略实现为自旋。如果很快有新的task进来，那就可以由CFS调度到该warm-core来，直接以高频高性能运行；如果一段时间没有task，则将该core降级为perserve，同时更改其idle策略……</p>
<p>这应该主要是用在服务器上，因为这种策略，以及后续的实现，应该会增加功耗&#x2F;发热，同时获得更好的性能表现。同时这个方案还是很有启发性的，涉及到了调度与电源管理的很多主题。</p>
<hr>
<h4 id="调度：RTLA"><a href="#调度：RTLA" class="headerlink" title="调度：RTLA"></a>调度：RTLA</h4><p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1265/attachments/1091/2093/2022_lpc_rtpa.pdf">RTLA: what is next? - Daniel Bristot de Oliveira LPC’22</a></p>
<p>rtla: real-time linxu analysis。（很新，rt相关，不太懂，转发一下）</p>
<hr>
<h4 id="Rust相关"><a href="#Rust相关" class="headerlink" title="Rust相关"></a>Rust相关</h4><ol>
<li><p>rust很有可能会在6.1进入内核，刚开始可能只是一个“hello world”玩具，但是会给社区一个信号，rust真正被接受了。</p>
</li>
<li><p>rust有很多相关工作正在进行，比如gccrs（rust的gcc前端）等。——这个项目比较缺人，目前还在紧张的开发周期中，如果有人感兴趣可以考虑参与一下。</p>
</li>
<li><p>rust与内核之间还有一些问题需要解决，比如inline、宏等。——换而言之，要想完全利用起来rust的安全特性，和内核无缝衔接，还有一些重要的问题需要解决。</p>
</li>
<li><p>整个社区中有很多人在关注，很多人在做前置开发，比如rust-nvme驱动，rust-9p驱动等等。</p>
</li>
<li><p>还有一个有趣的项目叫做Aya： Rust in kernel via eBPF，很炫酷……</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1256/attachments/1048/2003/Rust%20Status%20-%20LPC%202022.pdf">Rust for Linux Status Update - Miguel Ojeda LPC’22</a></p>
<p>(Miguel Ojeda是Rust in kernel的维护者，这个pdf里讲了rust当前的开发状态。——我没细看……)</p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1180/attachments/1017/1961/deck.pdf">Linux (PCI) NVMe driver in Rust - Andreas Hindborg (Western Diginal) LPC’22</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1215/attachments/1032/1980/LPC2022-gccrs.pdf">gccrs - Philip Herron &amp; David Faust LPC’22</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1182/attachments/997/1924/Rust%20in%20the%20Kernel.pdf">Rust in the Kernel via eBPF - Dave &amp; Michal LPC’22)</a></p>
<p><a target="_blank" rel="noopener" href="https://kangrejos.com/Async%20Rust%20and%209p%20server.pdf">Async Rust and 9p server - Wedson Almeida Filho</a></p>
<p><a target="_blank" rel="noopener" href="https://kangrejos.com/rustc_codegen_gcc:%20A%20gcc%20codegen%20for%20the%20Rust%20compiler.pdf">rustc_codegen_gcc: A gcc codegen for the Rust compiler - Antoni Boucher</a></p>
<hr>
<h4 id="安卓存储方案相关"><a href="#安卓存储方案相关" class="headerlink" title="安卓存储方案相关"></a>安卓存储方案相关</h4><p>最近比较关注安卓的存储方案，尤其是fuse-passthrough，以及virtual-A&#x2F;B方案。</p>
<p>android的数据访问高度依赖于fuse，因为它要通过fuse做动态的文件访问权限管控。所以引入了fuse直通，让内核可以直接基于某个本地文件系统的fd而完成数据传输，以避免数据拷贝和系统调用开销。当前的开发点是引入ebpf，来帮助内核做策略选择。</p>
<p>virtual-A&#x2F;B是系统存储&#x2F;OTA更新方案，是从A&#x2F;B,non-A&#x2F;B方案演化过来的，内部使用了dm-snapshot，dm-user，dm-linear等各种内核组件。当前的讨论点是尝试使用io_uring-based ublk，替代掉之前google自己维护的dm-user。</p>
<p>fuse:<br><a target="_blank" rel="noopener" href="https://lpc.events/event/11/contributions/1048/attachments/838/1662/2021%20LPC_%20FS%20stacking%20with%20FUSE_%20performance%20issues%20and%20mitigations.pdf">FS stacking with FUSE: performance issues and mitigations - Alessio Balsini &amp; Paul Lawrence LPC’21</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1339/attachments/945/1861/LPC2022%20Fuse-bpf.pdf">fuse-bpf - Daniel Rosenberg &amp; Paul Lawrence LPC’22</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/docs/core/storage/fuse-passthrough">FUSE Passthrough - Android</a></p>
<p>virtual-A&#x2F;B:<br><a target="_blank" rel="noopener" href="https://lpc.events/event/11/contributions/1049/attachments/826/1562/2021%20LPC_%20dm-snapshot%20in%20user%20space.pdf">dm-snapshot in userspace - Akilesh Kailash &amp; David Anderson LPC’21</a></p>
<p><a target="_blank" rel="noopener" href="https://lpc.events/event/16/contributions/1331/attachments/951/1867/LPC2022%20-%20io_uring%20in%20Android%20OTA.pdf">io_uring in Android OTA - Akilesh Kailash LPC’22</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/docs/core/ota/virtual_ab">Virtual A&#x2F;B Overview - Andriod</a></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/23/linux_news_vol_1/" data-id="cl8qsukv70001fbi50ygn16c6" data-title="一周Linux资讯 Vol. 1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%80%E5%91%A8linux%E8%B5%84%E8%AE%AF/">一周linux资讯</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/kernel/" rel="tag">kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/kernel/" style="font-size: 10px;">kernel</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/07/hello-test/">一周Linux资讯 Vol. 3</a>
          </li>
        
          <li>
            <a href="/2022/09/29/linux_news_vol_2/">一周Linux资讯 Vol. 2</a>
          </li>
        
          <li>
            <a href="/2022/09/23/linux_news_vol_1/">一周Linux资讯 Vol. 1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>